// -------------------------------------------------- //
// This file is autogenerated by pioasm; do not edit! //
// -------------------------------------------------- //

#pragma once

#if !PICO_NO_HARDWARE
#include "hardware/pio.h"
#endif

// ------- //
// sn75595 //
// ------- //

#define sn75595_wrap_target 0
#define sn75595_wrap 7
#define sn75595_pio_version 0

#define sn75595_NUM_DEVICES 1

static const uint16_t sn75595_program_instructions[] = {
            //     .wrap_target
    0x80a0, //  0: pull   block                      
    0xe027, //  1: set    x, 7                       
    0x6078, //  2: out    null, 24                   
    0x7001, //  3: out    pins, 1         side 0     
    0x1843, //  4: jmp    x--, 3          side 1     
    0xf000, //  5: set    pins, 0         side 0     
    0xe004, //  6: set    pins, 4                    
    0xe000, //  7: set    pins, 0                    
            //     .wrap
};

#if !PICO_NO_HARDWARE
static const struct pio_program sn75595_program = {
    .instructions = sn75595_program_instructions,
    .length = 8,
    .origin = -1,
    .pio_version = 0,
#if PICO_PIO_VERSION > 0
    .used_gpio_ranges = 0x0
#endif
};

static inline pio_sm_config sn75595_program_get_default_config(uint offset) {
    pio_sm_config c = pio_get_default_sm_config();
    sm_config_set_wrap(&c, offset + sn75595_wrap_target, offset + sn75595_wrap);
    sm_config_set_sideset(&c, 2, true, false);
    return c;
}

#include "hardware/clocks.h"
namespace sn74595 {
const uint32_t SHIFT_CLK  = 8000 * 1000;	// 8MHz
enum SN74595_PIN : uint	// GPIO pins to use
{
	PIN_DATA = 18,		// connect to SN74xx595 SER (pin 14)
	PIN_CLK,			// connect to SN74xx595 SERCLK (pin 11)
	PIN_LATCH			// connect to SN74xx595 RCLK (pin 12)
};
// IMPORTANT:
// Unless you control it from your application
// connect ~SERCLR (pin 10) to logic high (VCC) and
// ~OE (pin 13) to GND on all devices!
// Change pio and/or sm to whatever PIO and state machine you want to use
static const PIO 	pio = pio0;
static const uint	sm = 1;
static uint32_t 	registerState = 0;
void shiftreg_init() {
	const uint pin_base = PIN_DATA;
	// Tell PIO to initially drive output-low on the selected pin, then map PIO
	// onto that pin with the IO muxes.
	pio_sm_set_pins_with_mask(pio, sm, 0b111u, 0b0u << pin_base);
	pio_sm_set_consecutive_pindirs(pio, sm, pin_base, 3, true/*output*/);
	for(uint i=0;i<3;i++)
		pio_gpio_init(pio, pin_base+i);
	uint offset = pio_add_program(pio, &sn75595_program);
	pio_sm_config c = sn75595_program_get_default_config(offset);
	// OUT shifts to left, no autopull
	sm_config_set_out_shift(&c, false, false, 32);
	sm_config_set_out_pins(&c, pin_base, 1);
	sm_config_set_sideset_pins(&c, pin_base + 1);	   // pins to use in SIDE instr
	sm_config_set_set_pins(&c, pin_base + 0, 3);   // pins to use in SET instr
	float div = (float)clock_get_hz(clk_sys) / (SHIFT_CLK * 2);
	sm_config_set_clkdiv(&c, div);
	pio_sm_init(pio, sm, offset, &c);
	pio_sm_clear_fifos(pio, sm);
	pio_sm_set_enabled(pio, sm, true);
}
void shiftreg_send(uint32_t data) {
	while (pio_sm_is_tx_fifo_full(pio,sm)) {
		;
	}
	pio_sm_put_blocking(pio, sm, data);
}
void setDeviceOutput(int device, int dout, bool val){
	int gout = (device * 8) + dout;
	if(val)
		registerState |= (1 << gout);
	else
		registerState &= ~(1 << gout);
	shiftreg_send(registerState);
}
void setOutput(int device, int dout, bool val){
	int gout = (device * 8) + dout;
	if(val)
		registerState |= (1 << gout);
	else
		registerState &= ~(1 << gout);
}
void sendOutput(void) {
	shiftreg_send(registerState);
}
void setGlobalOutput(int gout, bool val){
	setDeviceOutput(gout / 8, gout % 8, val);
}
} // namespace

#endif

